diff -pur OpenModelica/Compiler/Ceval.mo OpenModelica-patched/Compiler/Ceval.mo
--- OpenModelica/Compiler/Ceval.mo	2008-02-19 10:12:22.000000000 +0100
+++ OpenModelica-patched/Compiler/Ceval.mo	2008-08-19 21:22:01.000000000 +0200
@@ -1916,7 +1916,7 @@ algorithm 
         pd = System.pathDelimiter();
         executableSuffixedExe = stringAppend(executable, System.getExeExt());
         sim_call = Util.stringAppendList(
-          {cit,executableSuffixedExe,cit," > output.log 2>&1"});
+          {cit,"./",executableSuffixedExe,cit," > output.log 2>&1"});
         0 = System.systemCall(sim_call);
         result_file = Util.stringAppendList({executable,"_res.plt"});
         simValue = Values.RECORD(Absyn.IDENT("SimulationResult"),
diff -pur OpenModelica/Compiler/omc_debug/Makefile.in OpenModelica-patched/Compiler/omc_debug/Makefile.in
--- OpenModelica/Compiler/omc_debug/Makefile.in	2008-02-19 10:11:48.000000000 +0100
+++ OpenModelica-patched/Compiler/omc_debug/Makefile.in	2008-08-19 21:22:01.000000000 +0200
@@ -36,9 +36,9 @@ include $(srcdir)/Makefile.common
 
 ifeq ($(OSTYP),$(OS_MSYS))
 	LIBSOCKET=
-	CORBALIB=-L$(CORBAHOME)/lib -lmico -lwsock32
+	CORBALIB=-L$(CORBAHOME)/lib -lmico2.3.12 -lwsock32
 else
-	CORBALIB=-L$(CORBAHOME)/lib -lmico -lcrypto -lssl -lpthread -lreadline
+	CORBALIB=-L$(CORBAHOME)/lib -lmico2.3.12 -lcrypto -lssl -lpthread -lreadline
 endif
 
 ifdef USE_CORBA
diff -pur OpenModelica/Compiler/omc_release/Makefile.in OpenModelica-patched/Compiler/omc_release/Makefile.in
--- OpenModelica/Compiler/omc_release/Makefile.in	2008-02-19 10:11:48.000000000 +0100
+++ OpenModelica-patched/Compiler/omc_release/Makefile.in	2008-08-19 21:22:01.000000000 +0200
@@ -36,9 +36,9 @@ include $(srcdir)/Makefile.common
 
 ifeq ($(OSTYP),$(OS_MSYS))
 	LIBSOCKET=
-	CORBALIB=-L$(CORBAHOME)/lib -lmico -lwsock32
+	CORBALIB=-L$(CORBAHOME)/lib -lmico2.3.12 -lwsock32
 else
-	CORBALIB=-L$(CORBAHOME)/lib -lmico -lcrypto -lssl -lpthread
+	CORBALIB=-L$(CORBAHOME)/lib -lmico2.3.12 -lcrypto -lssl -lpthread
 endif
 
 ifdef USE_CORBA
diff -pur OpenModelica/Compiler/runtime/corbaimpl_stub.cpp OpenModelica-patched/Compiler/runtime/corbaimpl_stub.cpp
--- OpenModelica/Compiler/runtime/corbaimpl_stub.cpp	2008-02-19 10:11:46.000000000 +0100
+++ OpenModelica-patched/Compiler/runtime/corbaimpl_stub.cpp	2008-08-19 21:22:01.000000000 +0200
@@ -25,13 +25,13 @@ void Corba_5finit(void)
 {	
 }
 
-void errmsg() {
+void errmsg_CORBA() {
   cerr << "CORBA disabled. Configure with --with-CORBA and recompile for enabling." << endl;
 }
 
 RML_BEGIN_LABEL(Corba__initialize)
 {
-  errmsg();
+  errmsg_CORBA();
   RML_TAILCALLK(rmlFC);
 }
 RML_END_LABEL
@@ -39,21 +39,21 @@ RML_END_LABEL
 
 RML_BEGIN_LABEL(Corba__waitForCommand)
 {
-  errmsg();
+  errmsg_CORBA();
   RML_TAILCALLK(rmlFC);
 }
 RML_END_LABEL
 
 RML_BEGIN_LABEL(Corba__sendreply)
 {
-  errmsg();
+  errmsg_CORBA();
   RML_TAILCALLK(rmlFC);
 }
 RML_END_LABEL
 
 RML_BEGIN_LABEL(Corba__close)
 {
-  errmsg();
+  errmsg_CORBA();
   RML_TAILCALLK(rmlFC);
 }
 RML_END_LABEL
diff -pur OpenModelica/Compiler/runtime/systemimpl.c OpenModelica-patched/Compiler/runtime/systemimpl.c
--- OpenModelica/Compiler/runtime/systemimpl.c	2008-02-19 10:11:46.000000000 +0100
+++ OpenModelica-patched/Compiler/runtime/systemimpl.c	2008-08-19 21:31:28.000000000 +0200
@@ -1,31 +1,31 @@
-/* 
+/*
  * This file is part of OpenModelica.
- * 
- * Copyright (c) 1998-2008, Linköpings University,
- * Department of Computer and Information Science, 
- * SE-58183 Linköping, Sweden. 
- * 
+ *
+ * Copyright (c) 1998-2008, Linkï¿½pings University,
+ * Department of Computer and Information Science,
+ * SE-58183 Linkï¿½ping, Sweden.
+ *
  * All rights reserved.
- * 
- * THIS PROGRAM IS PROVIDED UNDER THE TERMS OF THIS OSMC PUBLIC 
- * LICENSE (OSMC-PL). ANY USE, REPRODUCTION OR DISTRIBUTION OF 
- * THIS PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THE OSMC 
- * PUBLIC LICENSE. 
- * 
- * The OpenModelica software and the Open Source Modelica 
- * Consortium (OSMC) Public License (OSMC-PL) are obtained 
- * from Linköpings University, either from the above address, 
+ *
+ * THIS PROGRAM IS PROVIDED UNDER THE TERMS OF THIS OSMC PUBLIC
+ * LICENSE (OSMC-PL). ANY USE, REPRODUCTION OR DISTRIBUTION OF
+ * THIS PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THE OSMC
+ * PUBLIC LICENSE.
+ *
+ * The OpenModelica software and the Open Source Modelica
+ * Consortium (OSMC) Public License (OSMC-PL) are obtained
+ * from Linkï¿½pings University, either from the above address,
  * from the URL: http://www.ida.liu.se/projects/OpenModelica
  * and in the OpenModelica distribution.
- * 
- * This program is distributed  WITHOUT ANY WARRANTY; without 
- * even the implied warranty of  MERCHANTABILITY or FITNESS 
- * FOR A PARTICULAR PURPOSE, EXCEPT AS EXPRESSLY SET FORTH 
- * IN THE BY RECIPIENT SELECTED SUBSIDIARY LICENSE CONDITIONS 
- * OF OSMC-PL. 
- * 
+ *
+ * This program is distributed  WITHOUT ANY WARRANTY; without
+ * even the implied warranty of  MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE, EXCEPT AS EXPRESSLY SET FORTH
+ * IN THE BY RECIPIENT SELECTED SUBSIDIARY LICENSE CONDITIONS
+ * OF OSMC-PL.
+ *
  * See the full OSMC Public License conditions for more details.
- * 
+ *
  */
 
 /*
@@ -71,7 +71,7 @@ typedef struct modelica_ptr_s *modelica_
 
 #if defined(_MSC_VER)
 #define inline __inline
-#else // Linux & MinGW 
+#else // Linux & MinGW
 #define inline inline
 #endif
 
@@ -310,23 +310,23 @@ RML_BEGIN_LABEL(System__strtok)
 
   void * res = (void*)mk_nil();
   s=strtok(str,delimit);
-  if (s == NULL) 
+  if (s == NULL)
   {
 	  /* adrpo added 2004-10-27 */
-	  free(str);	  
-	  rmlA0=res; RML_TAILCALLK(rmlFC); 
+	  free(str);
+	  rmlA0=res; RML_TAILCALLK(rmlFC);
   }
   res = (void*)mk_cons(mk_scon(s),res);
-  while (s=strtok(NULL,delimit)) 
+  while (s=strtok(NULL,delimit))
   {
     res = (void*)mk_cons(mk_scon(s),res);
   }
   rmlA0=res;
 
   /* adrpo added 2004-10-27 */
-  free(str);	  
+  free(str);
 
-  /* adrpo changed 2004-10-29 
+  /* adrpo changed 2004-10-29
   rml_prim_once(RML__list_5freverse);
   RML_TAILCALLK(rmlSC);
   */
@@ -338,7 +338,7 @@ RML_BEGIN_LABEL(System__toupper)
 {
   char *str = strdup(RML_STRINGDATA(rmlA0));
   char *res=str;
-  while (*str!= '\0') 
+  while (*str!= '\0')
   {
     *str=toupper(*str++);
   }
@@ -362,12 +362,12 @@ RML_BEGIN_LABEL(System__removeFirstAndLa
       res=malloc(length-1);
       strncpy(res,str + 1,length-2);
 
-      res[length-1] = '\0';  
+      res[length-1] = '\0';
     }
   rmlA0 = (void*) mk_scon(res);
   /* adrpo added 2004-10-29 */
-  free(res); 
-  
+  free(res);
+
   RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
@@ -383,7 +383,7 @@ int str_contain_char( const char* chars,
     }
   return 0;
 }
- 
+
 
 /*  this removes chars in second from the beginning and end of the first
     string and returns it */
@@ -409,7 +409,7 @@ RML_BEGIN_LABEL(System__trim)
         }
 
 
-      res[length] = '\0';  
+      res[length] = '\0';
     }
   if(start_pos < end_pos)
     {
@@ -417,9 +417,9 @@ RML_BEGIN_LABEL(System__trim)
       rmlA0 = (void*) mk_scon(&res[start_pos]);
     } else {
       rmlA0 = (void*) mk_scon("");
-    }      
+    }
 
-  free(res); 
+  free(res);
 
 
   RML_TAILCALLK(rmlSC);
@@ -449,7 +449,7 @@ RML_BEGIN_LABEL(System__trimChar)
     rmlA0 = (void*) mk_scon(res);
     free(res);
     RML_TAILCALLK(rmlSC);
-    
+
   }else{
     rmlA0 = (void*) mk_scon("");
     RML_TAILCALLK(rmlSC);
@@ -478,15 +478,15 @@ RML_BEGIN_LABEL(System__stringFind)
   int strLen = strlen(str);
   int strSearchLen = strlen(searchStr);
   int i,retVal=-1;
-  
+
   for (i=0; i< strLen - strSearchLen+1; i++) {
-  	if (strncmp(&str[i],searchStr,strSearchLen) == 0) { 
-  		retVal = i; 
+  	if (strncmp(&str[i],searchStr,strSearchLen) == 0) {
+  		retVal = i;
   		break;
   	}
   }
-  rmlA0 = (void*) mk_icon(retVal);	
-  RML_TAILCALLK(rmlSC);  
+  rmlA0 = (void*) mk_icon(retVal);
+  RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
 
@@ -511,20 +511,20 @@ RML_BEGIN_LABEL(System__stringReplace)
   char * res=0;
 /*   printf("in '%s' replace '%s' with '%s'\n",str,source,target); */
 
-  /* adrpo 2006-05-15 
+  /* adrpo 2006-05-15
    * if source and target are the same this function
    * cycles, get rid of that here
    * x08joekl 2008-02-5
    * fixed so that _replace handles target having source as a substring.
    */
   /*
-   if (!strcmp(source, target)) 
+   if (!strcmp(source, target))
    	RML_TAILCALLK(rmlSC);
   */
   /* end adrpo */
 
   res = _replace(str,source,target);
-  if (res == NULL) 
+  if (res == NULL)
   {
 /*      printf("res == NULL\n");  */
     RML_TAILCALLK(rmlFC);
@@ -657,7 +657,7 @@ RML_BEGIN_LABEL(System__loadLibrary)
 #else
   snprintf(libname, MAXPATHLEN, "./%s.dll", str);
 #endif
-	  
+
   h = LoadLibrary(libname);
   if (h == NULL) {
     fprintf(stderr, "Unable to load `%s': %lu.\n", libname, GetLastError());
@@ -760,12 +760,12 @@ RML_BEGIN_LABEL(System__pwd)
   LPTSTR bufPtr=buf;
   DWORD bufLen = MAXPATHLEN;
   GetCurrentDirectory(bufLen,bufPtr);
-  
+
   /* Make sure windows paths use fronslash and not backslash */
   buf2=_replace(buf,"\\","/");
-  
+
   rmlA0 = (void*) mk_scon(buf2);
-  free(buf2);	
+  free(buf2);
   RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
@@ -776,7 +776,7 @@ RML_BEGIN_LABEL(System__writeFile)
   char* filename = RML_STRINGDATA(rmlA0);
   FILE * file=NULL;
   file = fopen(filename,"w");
-  if (file == NULL) { 
+  if (file == NULL) {
     char *c_tokens[1]={filename};
     c_add_message(21, /* WRITING_FILE_ERROR */
 		  "SCRIPTING",
@@ -785,8 +785,8 @@ RML_BEGIN_LABEL(System__writeFile)
 		  c_tokens,
 		  1);
     RML_TAILCALLK(rmlFC);
-  } 
-  /* adrpo changed 2006-10-06 
+  }
+  /* adrpo changed 2006-10-06
    * fprintf(file,"%s",data);
    */
   fwrite(RML_STRINGDATA(rmlA1), RML_HDRSTRLEN(RML_GETHDR(rmlA1)), 1, file);
@@ -820,7 +820,7 @@ RML_BEGIN_LABEL(System__readFile)
 
   file = fopen(filename,"rb");
   buf = malloc(statstr.st_size+1);
- 
+
   if( (res = fread(buf, sizeof(char), statstr.st_size, file)) != statstr.st_size)
   {
 	/* adrpo added 2004-10-26 */
@@ -844,7 +844,7 @@ RML_END_LABEL
 /*   char *path = getenv("OPENMODELICALIBRARY"); */
 /*   if (path == NULL)  */
 /*       RML_TAILCALLK(rmlFC); */
-  
+
 /*   rmlA0 = (void*) mk_scon(path); */
 /*   RML_TAILCALLK(rmlSC); */
 /* } */
@@ -872,7 +872,7 @@ RML_BEGIN_LABEL(System__setEnv)
   int setenv_result = 0;
   char *temp = (char*)malloc(strlen(envname)+strlen(envvalue)+2);
   sprintf(temp,"%s=%s", envname, envvalue);
-  setenv_result = _putenv(temp); 
+  setenv_result = _putenv(temp);
   rmlA0 = (void*) mk_icon(setenv_result);
   RML_TAILCALLK(rmlSC);
 }
@@ -898,9 +898,9 @@ RML_BEGIN_LABEL(System__subDirectories)
 	sh = FindFirstFile(pattern, &FileData);
 	if (sh != INVALID_HANDLE_VALUE) {
 		while(more) {
-			if (strcmp(FileData.cFileName,"..") != 0 && 
+			if (strcmp(FileData.cFileName,"..") != 0 &&
 				strcmp(FileData.cFileName,".") != 0 &&
-				(FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) 
+				(FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
 			{
 			    res = (void*)mk_cons(mk_scon(FileData.cFileName),res);
 			}
@@ -956,7 +956,7 @@ RML_BEGIN_LABEL(System__readPtolemyplotD
   rmlA0 = lst;
   rml_prim_once(RML__list_5flength);
   size = RML_UNTAGFIXNUM(rmlA0);
-  
+
   vars = (char**)malloc(sizeof(char*)*size);
   for (i=0,p=lst;i<size;i++) {
     vars[i]=RML_STRINGDATA(RML_CAR(p));
@@ -970,7 +970,7 @@ RML_BEGIN_LABEL(System__readPtolemyplotD
   rml_prim_once(Values__reverseMatrix);
 
   RML_TAILCALLK(rmlSC);
-}   
+}
 RML_END_LABEL
 
 RML_BEGIN_LABEL(System__readPtolemyplotDatasetSize)
@@ -980,23 +980,23 @@ RML_BEGIN_LABEL(System__readPtolemyplotD
   void* p;
 
   size=read_ptolemy_dataset_size(filename);
-  
+
   rmlA0 = (void*)Values__INTEGER(mk_icon(size));
   if (rmlA0 == NULL) {
     RML_TAILCALLK(rmlFC);
   }
   RML_TAILCALLK(rmlSC);
-}   
+}
 RML_END_LABEL
 
 RML_BEGIN_LABEL(System__writePtolemyplotDataset)
 {
   char *filename = RML_STRINGDATA(rmlA0);
   void *value = rmlA1;
-  
+
 
   RML_TAILCALLK(rmlSC);
-}   
+}
 RML_END_LABEL
 
 
@@ -1004,9 +1004,9 @@ RML_BEGIN_LABEL(System__time)
 {
   double _time;
   clock_t cl;
-  
+
   cl=clock();
-  
+
   _time = (double)cl / (double)CLOCKS_PER_SEC;
   /*  printf("clock : %d\n",cl); */
   /* printf("returning time: %f\n",time);  */
@@ -1202,28 +1202,28 @@ RML_END_LABEL
 RML_BEGIN_LABEL(System__getVariableValue)
 {
   double timeStamp 	= rml_prim_get_real(rmlA0);
-  void *timeValues 	= rmlA1;  
+  void *timeValues 	= rmlA1;
   void *varValues 	= rmlA2;
-  
+
   // values to find the correct range
   double preValue 	= 0.0;
   double preTime 	= 0.0;
   double nowValue 	= 0.0;
   double nowTime 	= 0.0;
-  
+
   // linjear interpolation data
   double timedif 			= 0.0;
   double valuedif			= 0.0;
   double valueSlope			= 0.0;
   double timeDifTimeStamp	= 0.0;
-  
+
   // break loop and return value
   int valueFound = 0;
   double returnValue = 0.0;
 
 for(; RML_GETHDR(timeValues) == RML_CONSHDR && valueFound == 0; timeValues = RML_CDR(timeValues), varValues = RML_CDR(varValues)) {
-  
-  
+
+
     nowValue 	= rml_prim_get_real(RML_CAR(varValues));
   	nowTime 	=  rml_prim_get_real(RML_CAR(timeValues));
 
@@ -1231,7 +1231,7 @@ for(; RML_GETHDR(timeValues) == RML_CONS
 	if(timeStamp == nowTime){
     	valueFound 	= 1;
     	returnValue = nowValue;
-    	
+
     } else if (timeStamp >= preTime && timeStamp <= nowTime) { // need to do interpolation
     	valueFound 			= 1;
     	timedif 			= nowTime - preTime;
@@ -1249,7 +1249,7 @@ for(; RML_GETHDR(timeValues) == RML_CONS
     	printf("\n");
     	printf("preValue: %f", preValue);
     	printf("\n");
-    	
+
 		printf("timedif: %f", timedif);
     	printf("\n");
     	printf("valuedif: %f", valuedif);
@@ -1264,7 +1264,7 @@ for(; RML_GETHDR(timeValues) == RML_CONS
 	} else {
 		preValue 	= nowValue;
   		preTime 	= nowTime;
-		
+
 	}
 
   }
@@ -1273,7 +1273,7 @@ for(; RML_GETHDR(timeValues) == RML_CONS
 		printf("\n WARNING: timestamp outside simulation timeline \n");
 		RML_TAILCALLK(rmlFC);
 	} else {
-  
+
   		rmlA0 = (void*)mk_rcon(returnValue);
   		RML_TAILCALLK(rmlSC);
   }
@@ -1282,18 +1282,18 @@ RML_END_LABEL
 
 RML_BEGIN_LABEL(System__sendData)
 {
- 
 
- 
 
-  	
+
+
+
   char* data = RML_STRINGDATA(rmlA0);
   char* interpolation = RML_STRINGDATA(rmlA1);
  char* title = RML_STRINGDATA(rmlA2);
  int legend = RML_UNTAGFIXNUM(rmlA3); //RML_STRINGDATA(rmlA3);
- int grid = RML_UNTAGFIXNUM(rmlA4); //RML_STRINGDATA(rmlA4); 
- int logX = RML_UNTAGFIXNUM(rmlA5); //RML_STRINGDATA(rmlA5);	
- int logY = RML_UNTAGFIXNUM(rmlA6); //RML_STRINGDATA(rmlA6);	 
+ int grid = RML_UNTAGFIXNUM(rmlA4); //RML_STRINGDATA(rmlA4);
+ int logX = RML_UNTAGFIXNUM(rmlA5); //RML_STRINGDATA(rmlA5);
+ int logY = RML_UNTAGFIXNUM(rmlA6); //RML_STRINGDATA(rmlA6);
  char* xLabel = RML_STRINGDATA(rmlA7);
  char* yLabel = RML_STRINGDATA(rmlA8);
  int points = RML_UNTAGFIXNUM(rmlA9);
@@ -1307,9 +1307,9 @@ RML_BEGIN_LABEL(System__sendData)
 
 //  emulateStreamData(data, 7778, title, "time", "", legend, grid, 0, 0, 0, 0, logX, logY, interpolation, 1);
   emulateStreamData(data, title, xLabel, yLabel , interpolation, legend, grid, logX, logY, points, range);
-  
+
 //	emulateStreamData(data, 7778, "Plot by OpenModelica", "time", "", 1, 1, 0, 0, 0, 0, 0, 0, "linear");
-       
+
   RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
@@ -1321,8 +1321,8 @@ RML_BEGIN_LABEL(System__enableSendData)
 		_putenv("enableSendData=1");
 	else
 		_putenv("enableSendData=0");
-		
-	
+
+
 //	enableSendData(enable);
 	  RML_TAILCALLK(rmlSC);
 }
@@ -1333,7 +1333,7 @@ RML_BEGIN_LABEL(System__setDataPort)
 	int port = RML_UNTAGFIXNUM(rmlA0);
 
 		char* dataport = malloc(25);
-		sprintf(dataport,"sendDataPort=%s", port); 
+		sprintf(dataport,"sendDataPort=%s", port);
 		_putenv(dataport);
 		free(dataport);
 //	setDataPort(port);
@@ -1360,17 +1360,17 @@ RML_BEGIN_LABEL(System__getFileModificat
   struct _stat attrib;			  // create a file attribute structure
   double elapsedTime;             // the time elapsed as double
   int result;					  // the result of the function call
-  
+
   result = _stat( fileName, &attrib );
-  
+
   if( result != 0 )
   {
   	rmlA0 = mk_none();     // we couldn't get the time, return NONE
-  }  
+  }
   else
   {
-    rmlA0 = mk_some(mk_rcon(difftime(attrib.st_mtime, 0))); // the file modification time 
-  }  
+    rmlA0 = mk_some(mk_rcon(difftime(attrib.st_mtime, 0))); // the file modification time
+  }
   RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
@@ -1380,21 +1380,21 @@ RML_BEGIN_LABEL(System__getCurrentTime)
   time_t t;
   double elapsedTime;             // the time elapsed as double
   time( &t );
-  rmlA0 = mk_rcon(difftime(t, 0)); // the file modification time  
+  rmlA0 = mk_rcon(difftime(t, 0)); // the file modification time
   RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
 
-/* 
+/*
  * @author adrpo
  * this function sets the depth of variable showing in Eclipse.
  * it has no effect if is called within source not compiled in debug mode
  */
 RML_BEGIN_LABEL(System__setDebugShowDepth)
 {
-#ifdef RML_DEBUG   
+#ifdef RML_DEBUG
   rmldb_depth_of_variable_print = RML_UNTAGFIXNUM(rmlA0);
-#endif  
+#endif
   RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
@@ -1438,8 +1438,8 @@ typedef int _file_compar_func_type(const
 
 
 
-void reallocdirents(struct dirent ***entries, 
-		    unsigned int oldsize, 
+void reallocdirents(struct dirent ***entries,
+		    unsigned int oldsize,
 		    unsigned int newsize) {
   struct dirent **newentries;
   if (newsize<=oldsize)
@@ -1458,12 +1458,12 @@ void reallocdirents(struct dirent ***ent
 }
 
 
-/* 
+/*
  * compar function is ignored
  */
-int scandir(const char* dirname, 
-	    struct dirent ***entries, 
-	    _file_select_func_type select, 
+int scandir(const char* dirname,
+	    struct dirent ***entries,
+	    _file_select_func_type select,
 	    _file_compar_func_type compar)
 {
   DIR *dir = opendir(dirname);
@@ -1482,12 +1482,12 @@ int scandir(const char* dirname, 
 	unsigned int oldmaxents = maxents;
 	maxents = maxents * 2;
 	reallocdirents(entries, oldmaxents, maxents);
-      }	
+      }
       (*entries)[count] = entcopy;
       count++;
     }
   } while (count < maxents); /* shouldn't be needed */
-  /* 
+  /*
      write code for calling qsort using compar for sorting the
      entries.
   */
@@ -1524,7 +1524,7 @@ void System_5finit(void)
 
 	set_cc("gcc");
     set_cxx("g++");
-    set_linker("gcc -export-dynamic -shared");
+    set_linker("gcc -export-dynamic -shared -fPIC");
 	set_cflags("${MODELICAUSERCFLAGS}");
     set_ldflags("-lc_runtime");
 
@@ -1544,23 +1544,23 @@ RML_BEGIN_LABEL(System__strtok)
 
   void * res = (void*)mk_nil();
   s=strtok(str,delimit);
-  if (s == NULL) 
+  if (s == NULL)
   {
 	  /* adrpo added 2004-10-27 */
-	  free(str);	  
-	  rmlA0=res; RML_TAILCALLK(rmlFC); 
+	  free(str);
+	  rmlA0=res; RML_TAILCALLK(rmlFC);
   }
   res = (void*)mk_cons(mk_scon(s),res);
-  while (s=strtok(NULL,delimit)) 
+  while (s=strtok(NULL,delimit))
   {
     res = (void*)mk_cons(mk_scon(s),res);
   }
   rmlA0=res;
 
   /* adrpo added 2004-10-27 */
-  free(str);	  
+  free(str);
 
-  /* adrpo changed 2004-10-29 
+  /* adrpo changed 2004-10-29
   rml_prim_once(RML__list_5freverse);
   RML_TAILCALLK(rmlSC);
   */
@@ -1572,7 +1572,7 @@ RML_BEGIN_LABEL(System__toupper)
 {
   char *str = strdup(RML_STRINGDATA(rmlA0));
   char *res=str;
-  while (*str!= '\0') 
+  while (*str!= '\0')
   {
     *str=toupper(*str++);
   }
@@ -1596,12 +1596,12 @@ RML_BEGIN_LABEL(System__removeFirstAndLa
       res=malloc(length-1);
       strncpy(res,str + 1,length-2);
 
-      res[length-1] = '\0';  
+      res[length-1] = '\0';
     }
   rmlA0 = (void*) mk_scon(res);
   /* adrpo added 2004-10-29 */
-  free(res); 
-  
+  free(res);
+
   RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
@@ -1617,7 +1617,7 @@ int str_contain_char( const char* chars,
     }
   return 0;
 }
- 
+
 
 /*  this removes chars in second from the beginning and end of the first
     string and returns it */
@@ -1643,7 +1643,7 @@ RML_BEGIN_LABEL(System__trim)
         }
 
 
-      res[length] = '\0';  
+      res[length] = '\0';
     }
   if(start_pos < end_pos)
     {
@@ -1651,9 +1651,9 @@ RML_BEGIN_LABEL(System__trim)
       rmlA0 = (void*) mk_scon(&res[start_pos]);
     } else {
       rmlA0 = (void*) mk_scon("");
-    }      
+    }
 
-  free(res); 
+  free(res);
 
 
   RML_TAILCALLK(rmlSC);
@@ -1683,7 +1683,7 @@ RML_BEGIN_LABEL(System__trimChar)
     rmlA0 = (void*) mk_scon(res);
     free(res);
     RML_TAILCALLK(rmlSC);
-    
+
   }else{
     rmlA0 = (void*) mk_scon("");
     RML_TAILCALLK(rmlSC);
@@ -1711,15 +1711,15 @@ RML_BEGIN_LABEL(System__stringFind)
   int strLen = strlen(str);
   int strSearchLen = strlen(searchStr);
   int i,retVal=-1;
-  
+
   for (i=0; i< strLen - strSearchLen+1; i++) {
-    if (strncmp(&str[i],searchStr,strSearchLen) == 0) { 
-        retVal = i; 
+    if (strncmp(&str[i],searchStr,strSearchLen) == 0) {
+        retVal = i;
         break;
     }
   }
-  rmlA0 = (void*) mk_icon(retVal);  
-  RML_TAILCALLK(rmlSC);  
+  rmlA0 = (void*) mk_icon(retVal);
+  RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
 
@@ -1989,7 +1989,7 @@ RML_BEGIN_LABEL(System__writeFile)
 		  1);
     RML_TAILCALLK(rmlFC);
   }
-  /* adrpo changed 2006-10-06 
+  /* adrpo changed 2006-10-06
    * fprintf(file,"%s",data);
    */
   fwrite(RML_STRINGDATA(rmlA1), RML_HDRSTRLEN(RML_GETHDR(rmlA1)), 1, file);
@@ -2023,7 +2023,7 @@ RML_BEGIN_LABEL(System__readFile)
 
   file = fopen(filename,"rb");
   buf = malloc(statstr.st_size+1);
- 
+
   if( (res = fread(buf, sizeof(char), statstr.st_size, file)) != statstr.st_size)
   {
 	/* adrpo added 2004-10-26 */
@@ -2047,7 +2047,7 @@ RML_END_LABEL
 /*   char *path = getenv("OPENMODELICALIBRARY"); */
 /*   if (path == NULL)  */
 /*       RML_TAILCALLK(rmlFC); */
-  
+
 /*   rmlA0 = (void*) mk_scon(path); */
 
 /*   RML_TAILCALLK(rmlSC); */
@@ -2058,7 +2058,7 @@ RML_BEGIN_LABEL(System__readEnv)
 {
   char* envname = RML_STRINGDATA(rmlA0);
   char *envvalue = getenv(envname);
-  if (envvalue == NULL) 
+  if (envvalue == NULL)
   {
     RML_TAILCALLK(rmlFC);
   }
@@ -2115,7 +2115,7 @@ RML_BEGIN_LABEL(System__subDirectories)
   select_from_dir = directory;
   count = scandir(directory, &files, file_select_directories, NULL);
   res = (void*)mk_nil();
-  for (i=0; i<count; i++) 
+  for (i=0; i<count; i++)
   {
     res = (void*)mk_cons(mk_scon(files[i]->d_name),res);
     /* adrpo added 2004-10-28 */
@@ -2158,7 +2158,7 @@ RML_BEGIN_LABEL(System__moFiles)
   select_from_dir = directory;
   count = scandir(directory, &files, file_select_mo, NULL);
   res = (void*)mk_nil();
-  for (i=0; i<count; i++) 
+  for (i=0; i<count; i++)
   {
     res = (void*)mk_cons(mk_scon(files[i]->d_name),res);
     /* adrpo added 2004-10-28 */
@@ -2181,7 +2181,7 @@ RML_BEGIN_LABEL(System__readPtolemyplotD
   rmlA0 = lst;
   rml_prim_once(RML__list_5flength);
   size = RML_UNTAGFIXNUM(rmlA0);
-  
+
   vars = (char**)malloc(sizeof(char*)*size);
   for (i=0,p=lst;i<size;i++) {
     vars[i]=RML_STRINGDATA(RML_CAR(p));
@@ -2195,7 +2195,7 @@ RML_BEGIN_LABEL(System__readPtolemyplotD
   rml_prim_once(Values__reverseMatrix);
 
   RML_TAILCALLK(rmlSC);
-}   
+}
 RML_END_LABEL
 
 RML_BEGIN_LABEL(System__readPtolemyplotDatasetSize)
@@ -2205,23 +2205,23 @@ RML_BEGIN_LABEL(System__readPtolemyplotD
   void* p;
 
   size=read_ptolemy_dataset_size(filename);
-  
+
   rmlA0 = (void*)Values__INTEGER(mk_icon(size));
   if (rmlA0 == NULL) {
     RML_TAILCALLK(rmlFC);
   }
   RML_TAILCALLK(rmlSC);
-}   
+}
 RML_END_LABEL
 
 RML_BEGIN_LABEL(System__writePtolemyplotDataset)
 {
   char *filename = RML_STRINGDATA(rmlA0);
   void *value = rmlA1;
-  
+
 
   RML_TAILCALLK(rmlSC);
-}   
+}
 RML_END_LABEL
 
 
@@ -2229,9 +2229,9 @@ RML_BEGIN_LABEL(System__time)
 {
   double time;
   clock_t cl;
-  
+
   cl=clock();
-  
+
   time = (double)cl / (double)CLOCKS_PER_SEC;
   /*  printf("clock : %d\n",cl); */
   /* printf("returning time: %f\n",time);  */
@@ -2273,10 +2273,10 @@ RML_BEGIN_LABEL(System__directoryExists)
   char* str = RML_STRINGDATA(rmlA0);
   int ret_val;
   struct stat buf;
-  
+
   if (str == NULL)
   	RML_TAILCALLK(rmlFC);
-		  
+
   ret_val = stat(str, &buf);
   if (ret_val != 0 ) {
     rmlA0 = (void*) mk_icon(1);
@@ -2321,8 +2321,8 @@ RML_BEGIN_LABEL(System__platform)
   rmlA0 = (void*) mk_scon("WIN32");
   RML_TAILCALLK(rmlSC);
 }
-RML_END_LABEL 
-#elif defined CYGWIN 
+RML_END_LABEL
+#elif defined CYGWIN
 RML_BEGIN_LABEL(System__platform)
 {
   rmlA0 = (void*) mk_scon("CYGWIN");
@@ -2428,28 +2428,28 @@ char* compile_command = NULL;
 RML_BEGIN_LABEL(System__getVariableValue)
 {
   double timeStamp 	= rml_prim_get_real(rmlA0);
-  void *timeValues 	= rmlA1;  
+  void *timeValues 	= rmlA1;
   void *varValues 	= rmlA2;
-  
+
   // values to find the correct range
   double preValue 	= 0.0;
   double preTime 	= 0.0;
   double nowValue 	= 0.0;
   double nowTime 	= 0.0;
-  
+
   // linjear interpolation data
   double timedif 			= 0.0;
   double valuedif			= 0.0;
   double valueSlope			= 0.0;
   double timeDifTimeStamp	= 0.0;
-  
+
   // break loop and return value
   int valueFound = 0;
   double returnValue = 0.0;
 
 for(; RML_GETHDR(timeValues) == RML_CONSHDR && valueFound == 0; timeValues = RML_CDR(timeValues), varValues = RML_CDR(varValues)) {
-  
-  
+
+
     nowValue 	= rml_prim_get_real(RML_CAR(varValues));
   	nowTime 	=  rml_prim_get_real(RML_CAR(timeValues));
 
@@ -2457,7 +2457,7 @@ for(; RML_GETHDR(timeValues) == RML_CONS
 	if(timeStamp == nowTime){
     	valueFound 	= 1;
     	returnValue = nowValue;
-    	
+
     } else if (timeStamp >= preTime && timeStamp <= nowTime) { // need to do interpolation
     	valueFound 			= 1;
     	timedif 			= nowTime - preTime;
@@ -2475,7 +2475,7 @@ for(; RML_GETHDR(timeValues) == RML_CONS
     	printf("\n");
     	printf("preValue: %f", preValue);
     	printf("\n");
-    	
+
 		printf("timedif: %f", timedif);
     	printf("\n");
     	printf("valuedif: %f", valuedif);
@@ -2490,7 +2490,7 @@ for(; RML_GETHDR(timeValues) == RML_CONS
 	} else {
 		preValue 	= nowValue;
   		preTime 	= nowTime;
-		
+
 	}
 
   }
@@ -2499,7 +2499,7 @@ for(; RML_GETHDR(timeValues) == RML_CONS
 		printf("\n WARNING: timestamp outside simulation timeline \n");
 		RML_TAILCALLK(rmlFC);
 	} else {
-  
+
   		rmlA0 = (void*)mk_rcon(returnValue);
   		RML_TAILCALLK(rmlSC);
   }
@@ -2508,14 +2508,14 @@ RML_END_LABEL
 
 RML_BEGIN_LABEL(System__sendData)
 {
-   	
+
   char* data = RML_STRINGDATA(rmlA0);
   char* interpolation = RML_STRINGDATA(rmlA1);
  char* title = RML_STRINGDATA(rmlA2);
  int legend = RML_UNTAGFIXNUM(rmlA3); //RML_STRINGDATA(rmlA3);
- int grid = RML_UNTAGFIXNUM(rmlA4); //RML_STRINGDATA(rmlA4); 
- int logX = RML_UNTAGFIXNUM(rmlA5); //RML_STRINGDATA(rmlA5);	
- int logY = RML_UNTAGFIXNUM(rmlA6); //RML_STRINGDATA(rmlA6);	 
+ int grid = RML_UNTAGFIXNUM(rmlA4); //RML_STRINGDATA(rmlA4);
+ int logX = RML_UNTAGFIXNUM(rmlA5); //RML_STRINGDATA(rmlA5);
+ int logY = RML_UNTAGFIXNUM(rmlA6); //RML_STRINGDATA(rmlA6);
  char* xLabel = RML_STRINGDATA(rmlA7);
  char* yLabel = RML_STRINGDATA(rmlA8);
  int points = RML_UNTAGFIXNUM(rmlA9);
@@ -2527,11 +2527,11 @@ RML_BEGIN_LABEL(System__sendData)
 ///  emulateStreamData(data, 7778, "Plot by OpenModelica", "time", "", 1, 1, 0, 0, 0, 0, 0, 0, interpolation, 1);
 
 //  emulateStreamData(data, 7778, title, "time", "", legend, grid, 0, 0, 0, 0, logX, logY, interpolation, 1);
-// emulateStreamData(data, title, xLabel, yLabel , interpolation, legend, grid, logX, logY, points, range); 
+// emulateStreamData(data, title, xLabel, yLabel , interpolation, legend, grid, logX, logY, points, range);
   emulateStreamData(data, 7778, title, xLabel, yLabel , interpolation, legend, grid, 0, 0, 0, 0, logX, logY, points, range);
-  
+
 //	emulateStreamData(data, 7778, "Plot by OpenModelica", "time", "", 1, 1, 0, 0, 0, 0, 0, 0, "linear");
-       
+
   RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
@@ -2561,7 +2561,7 @@ RML_BEGIN_LABEL(System__setDataPort)
 RML_END_LABEL
 RML_BEGIN_LABEL(System__setVariableFilter)
 {
-	char * variables = RML_STRINGDATA(rmlA0);	
+	char * variables = RML_STRINGDATA(rmlA0);
 	setenv("sendDataFilter", variables, 1 /* overwrite */);
 //	setVariableFilter(variables);
 	RML_TAILCALLK(rmlSC);
@@ -2575,18 +2575,18 @@ RML_BEGIN_LABEL(System__getFileModificat
   struct stat attrib;			      // create a file attribute structure
   double elapsedTime;                 // the time elapsed as double
   int result;					      // the result of the function call
-  
+
   result =   stat(fileName, &attrib); // get the attributes of the file
-  
+
   if( result != 0 )
   {
   	rmlA0 = mk_none();     // we couldn't get the time, return NONE
-  }  
+  }
   else
   {
-    rmlA0 = mk_some(mk_rcon(difftime(attrib.st_mtime, 0))); // the file modification time 
-  }  
-  
+    rmlA0 = mk_some(mk_rcon(difftime(attrib.st_mtime, 0))); // the file modification time
+  }
+
   RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
@@ -2596,21 +2596,21 @@ RML_BEGIN_LABEL(System__getCurrentTime)
   time_t t;
   double elapsedTime;             // the time elapsed as double
   time( &t );
-  rmlA0 = mk_rcon(difftime(t, 0)); // the file modification time  
+  rmlA0 = mk_rcon(difftime(t, 0)); // the file modification time
   RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
 
-/* 
+/*
  * @author adrpo
  * this function sets the depth of variable showing in Eclipse.
  * it has no effect if is called within source not compiled in debug mode
  */
 RML_BEGIN_LABEL(System__setDebugShowDepth)
 {
-#ifdef RML_DEBUG   
+#ifdef RML_DEBUG
   rmldb_depth_of_variable_print = RML_UNTAGFIXNUM(rmlA0);
-#endif  
+#endif
   RML_TAILCALLK(rmlSC);
 }
 RML_END_LABEL
diff -pur OpenModelica/Compiler/SimCodegen.mo OpenModelica-patched/Compiler/SimCodegen.mo
--- OpenModelica/Compiler/SimCodegen.mo	2008-02-19 10:12:24.000000000 +0100
+++ OpenModelica-patched/Compiler/SimCodegen.mo	2008-08-19 21:22:01.000000000 +0200
@@ -142,6 +142,7 @@ public function generateMakefile "functi
           " $(CFLAGS)",
           " -I.",
           " -o ",cname,"$(EXEEXT) ",cpp_file,
+          " -static",
           " -lsim",
           " $(LDFLAGS)",
           " -lf2c",
diff -pur OpenModelica/configure OpenModelica-patched/configure
--- OpenModelica/configure	2008-02-19 10:12:58.000000000 +0100
+++ OpenModelica-patched/configure	2008-08-19 21:22:01.000000000 +0200
@@ -3232,7 +3232,7 @@ done
 
 echo "$as_me:$LINENO: checking for rml includefiles in $RMLHOME" >&5
 echo $ECHO_N "checking for rml includefiles in $RMLHOME... $ECHO_C" >&6
-rmlinc=`find $RMLHOME -follow -type d -name plain |grep include/plain`
+rmlinc=`find ${RMLHOME}/include -follow -type d -name plain |grep include/plain`
 if test -z "$rmlinc" ; then
   { { echo "$as_me:$LINENO: error: rml headers not found" >&5
 echo "$as_me: error: rml headers not found" >&2;}
@@ -3246,7 +3246,7 @@ fi
 
 echo "$as_me:$LINENO: checking for antlr header files" >&5
 echo $ECHO_N "checking for antlr header files... $ECHO_C" >&6
-antlrinc=`find $ANTLRHOME /usr/local/include /usr/include -type f -name TreeParser.hpp -print | head -1 | awk -F/ '{ total="";for (i = 1 ; i < NF-1; i++) total= total $i "/"; print total}'`
+antlrinc=`find ${ANTLRHOME}/include /usr/local/include /usr/include -type f -name TreeParser.hpp -print | head -1 | awk -F/ '{ total="";for (i = 1 ; i < NF-1; i++) total= total $i "/"; print total}'`
 if test -z "$antlrinc" ; then
   { { echo "$as_me:$LINENO: error: Could not find antlr include files" >&5
 echo "$as_me: error: Could not find antlr include files" >&2;}
@@ -3258,7 +3258,7 @@ fi
 
 echo "$as_me:$LINENO: checking for antlr libs" >&5
 echo $ECHO_N "checking for antlr libs... $ECHO_C" >&6
-antlrlib=`find $ANTLRHOME /usr/local/lib /usr/lib -type f -name libantlr.a -print | head -1 | awk -F/ '{ total="";for (i = 1 ; i < NF; i++) total= total $i "/"; print total}'`
+antlrlib=`find -L ${ANTLRHOME}/lib /usr/local/lib /usr/lib -type f -name libantlr.a -print | head -1 | awk -F/ '{ total="";for (i = 1 ; i < NF; i++) total= total $i "/"; print total}'`
 if test -z "$antlrlib" ; then
   { { echo "$as_me:$LINENO: error: Could not find antlr lib file" >&5
 echo "$as_me: error: Could not find antlr lib file" >&2;}
@@ -3310,7 +3310,7 @@ if test -d /home/pelab/pkg/gnu/lib ; the
   echo "$as_me:$LINENO: result: yes" >&5
 echo "${ECHO_T}yes" >&6
 else
-  readlinelib=`find /usr/lib /usr/local/lib -name libreadline.a | tail -1 | awk -F/ '{ total="";for (i = 1 ; i < NF; i++) total= total $i "/"; print total}'`
+  readlinelib=`find -L /usr/lib /usr/local/lib -name libreadline.a | tail -1 | awk -F/ '{ total="";for (i = 1 ; i < NF; i++) total= total $i "/"; print total}'`
   if test -z "$readlinelib" ; then
      echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6
diff -pur OpenModelica/c_runtime/Makefile OpenModelica-patched/c_runtime/Makefile
--- OpenModelica/c_runtime/Makefile	2008-02-19 10:10:38.000000000 +0100
+++ OpenModelica-patched/c_runtime/Makefile	2008-08-19 21:22:01.000000000 +0200
@@ -6,7 +6,7 @@ builddir_inc=$(top_builddir)/build/inclu
 CC = gcc
 FC = g77
 AR = ar -ru 
-CFLAGS = -O -fexceptions -Wall -ansi -pedantic -I$(top_builddir)/mosh/src/ $(EXTRA_CFLAGS)
+CFLAGS = -O -fexceptions -fPIC -Wall -ansi -pedantic -I$(top_builddir)/mosh/src/ $(EXTRA_CFLAGS)
 CPPFLAGS = $(CFLAGS)
 FFLAGS  = -O -fexceptions
 # P.A: before, g77 had -O3 or -O2 but that caused a bug in DDASRT, giving infinite loop.
diff -pur OpenModelica/OMShell/OMShell.pro OpenModelica-patched/OMShell/OMShell.pro
--- OpenModelica/OMShell/OMShell.pro	2008-02-19 10:11:26.000000000 +0100
+++ OpenModelica-patched/OMShell/OMShell.pro	2008-08-19 21:22:01.000000000 +0200
@@ -1,8 +1,8 @@
 TEMPLATE = app
 
 DEPENDPATH += .
-INCLUDEPATH += /home/adrpo/dev/mico-2.3.12/include
-LIBS+=-L/home/adrpo/dev/mico-2.3.12/lib -lmico2.3.12   -lssl -lcrypto -ldl -lbsd -lm  -lpthread
+INCLUDEPATH += .
+LIBS+= $$system(mico-config --libs)
 CONFIG += warn_on
 QT += network xml 
 
@@ -18,3 +18,5 @@ SOURCES += commandcompletion.cpp \  
            oms.cpp \
            main.cpp
 
+RESOURCES += oms.qrc
+
diff -pur OpenModelica/OMShell/oms.qrc OpenModelica-patched/OMShell/oms.qrc
--- OpenModelica/OMShell/oms.qrc	2008-02-19 10:11:26.000000000 +0100
+++ OpenModelica-patched/OMShell/oms.qrc	2008-08-19 21:22:01.000000000 +0200
@@ -1,14 +1,14 @@
 <RCC>
     <qresource prefix="/" >
-        <file>Resources\OMS.bmp</file>
-        <file>Resources\OMS.ico</file>
-        <file>Resources\clear.bmp</file>
-        <file>Resources\copy.bmp</file>
-        <file>Resources\cut.bmp</file>
-        <file>Resources\help.bmp</file>
-        <file>Resources\paste.bmp</file>
-        <file>Resources\print.bmp</file>
-        <file>Resources\start.bmp</file>
-        <file>Resources\stop.bmp</file>
+        <file>Resources/OMS.bmp</file>
+        <file>Resources/OMS.ico</file>
+        <file>Resources/clear.bmp</file>
+        <file>Resources/copy.bmp</file>
+        <file>Resources/cut.bmp</file>
+        <file>Resources/help.bmp</file>
+        <file>Resources/paste.bmp</file>
+        <file>Resources/print.bmp</file>
+        <file>Resources/start.bmp</file>
+        <file>Resources/stop.bmp</file>
     </qresource>
 </RCC>
